{"version":3,"sources":["gridHelpers.ts","settings.ts","components/Floor/Floor.tsx","components/Robot/robot-vacuum-cleaner.svg","components/Robot/Robot.tsx","gridReducer.ts","App.tsx","index.tsx"],"names":["Direction","settings","Floor","grid","map","row","index","Row","column","Col","clean","styled","div","Robot","position","animate","React","useState","rotationAngle","setRotationAngle","previousPosititon","useRef","useEffect","current","x","y","RobotWrapper","RobotImage","rotation","src","robot","alt","img","checkIsGridComplete","every","getRandomAllowedDirection","currentPosition","allowedDirections","push","WEST","EAST","NORTH","SOUTH","Math","floor","random","length","getInitialState","array2d","i","Array","fill","generateGrid","getNextMove","state","direction","getRandomAdjacentPosition","gridReducer","action","type","Error","AppContainer","Room","Panel","ResetButton","button","Status","p","complete","App","useReducer","dispatch","totalTimeInMillis","setTotalTimeInMillis","movementInterval","window","setInterval","clearTimeout","secondsPassed","toFixed","hasStarted","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3d779606.chunk.js","sourcesContent":["import { ICoordinate } from './interfaces';\nimport { settings } from './settings';\n\nenum Direction {\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST\n}\n\nexport const generateGrid = (): boolean[][] => {\n  const array2d: boolean[][] = [];\n\n  for (let i = 0; i < settings.GRID_SIZE; i++) {\n    const x = Array(settings.GRID_SIZE).fill(false);\n    array2d.push(x);\n  }\n\n  return array2d;\n};\n\nexport const checkIsGridComplete = (grid: boolean[][]): boolean => {\n  return grid.every(row => row.every(column => column));\n};\n\nexport const getRandomPosition = (): ICoordinate => {\n  const randomX = Math.floor(Math.random() * settings.GRID_SIZE);\n  const randomY = Math.floor(Math.random() * settings.GRID_SIZE);\n\n  return {x: randomX, y: randomY};\n};\n\nexport const getRandomAdjacentPosition = (currentPosition: ICoordinate): ICoordinate => {\n  const direction = getRandomAllowedDirection(currentPosition);\n  const {x, y} = currentPosition;\n\n  if (direction === Direction.WEST) {\n    return {x: x-1, y};\n  } else if (direction === Direction.EAST) {\n    return {x: x+1, y};\n  } else if (direction === Direction.NORTH) {\n    return { x, y: y-1};\n  } else if (direction === Direction.SOUTH) {\n    return {x, y: y+1};\n  }\n\n  return {x, y};\n};\n\nconst getRandomAllowedDirection = (currentPosition: ICoordinate): Direction => {\n  const allowedDirections = [];\n\n  if (currentPosition.x > 0) {\n    allowedDirections.push(Direction.WEST);\n  }\n\n  if (currentPosition.x < settings.GRID_SIZE-1) {\n    allowedDirections.push(Direction.EAST);\n  }\n\n  if (currentPosition.y > 0) {\n    allowedDirections.push(Direction.NORTH);\n  }\n\n  if (currentPosition.y < settings.GRID_SIZE-1) {\n    allowedDirections.push(Direction.SOUTH);\n  }\n\n  const randomIndex = Math.floor(Math.random() * allowedDirections.length);\n\n  return allowedDirections[randomIndex];\n};","export const settings = {\n  GRID_SIZE: 10,\n  ROBOT_SPEED_IN_MILLIS: 500,\n  TILE_SIZE_IN_PX: 50\n};","import React from 'react';\nimport styled from 'styled-components';\nimport { settings } from '../../settings';\n\ninterface IFloorProps {\n  grid: boolean[][];\n}\n\nexport const Floor: React.FC<IFloorProps> = ({grid}) => {\n  return (\n    <>\n      {grid.map((row, index) => (\n        <Row key={index}>\n          {row.map((column, index) => (\n            <Col clean={column} key={index} />\n          ))}\n        </Row>\n      ))}\n    </>\n  );\n};\n\nconst Row = styled.div`\n  display: flex;\n`;\n\nconst Col = styled.div<{clean: boolean}>`\n  width: ${settings.TILE_SIZE_IN_PX}px;\n  height: ${settings.TILE_SIZE_IN_PX}px;\n  background-color: ${({clean}) => clean ? '#a4d2a4' : '#d5c6bb'};\n  border: 1px solid #fff;\n  box-sizing: border-box;\n  transition: background-color ${settings.ROBOT_SPEED_IN_MILLIS/1000}s;\n`;","export default __webpack_public_path__ + \"static/media/robot-vacuum-cleaner.bf037834.svg\";","import React from 'react';\nimport { settings } from '../../settings';\nimport robot from './robot-vacuum-cleaner.svg';\nimport styled from 'styled-components';\nimport { ICoordinate } from '../../interfaces';\n\ninterface IRobotProps {\n  position: ICoordinate;\n  animate: boolean;\n};\n\nexport const Robot: React.FC<IRobotProps> = ({position, animate}) => {\n  const [rotationAngle, setRotationAngle] = React.useState<number>(0);\n  const previousPosititon = React.useRef<ICoordinate|null>(null);\n\n  React.useEffect(() => {\n    setRotationAngle(0);\n    if (previousPosititon.current && animate) {\n      if (position.x > previousPosititon.current.x) {\n        setRotationAngle(90);\n      } else if (position.x < previousPosititon.current.x) {\n        setRotationAngle(270);\n      } else if (position.y > previousPosititon.current.y) {\n        setRotationAngle(180);\n      } else {\n        setRotationAngle(0);\n      }\n    }\n    previousPosititon.current = position;\n  }, [position, animate]);\n\n  return (\n    <RobotWrapper position={position} animate={animate}>\n      <RobotImage rotation={rotationAngle} src={robot} alt=\"robot\" />\n    </RobotWrapper>\n  );\n};\n\nconst RobotWrapper = styled.div<{position: ICoordinate, animate: boolean}>`\n  position: absolute;\n  transform: translate(\n    ${({position}) => position.x * settings.TILE_SIZE_IN_PX}px,\n    ${({position}) => position.y * settings.TILE_SIZE_IN_PX}px\n  );\n  transition: ${({animate}) => animate ? `transform ${settings.ROBOT_SPEED_IN_MILLIS/1000}s linear` : ''};\n`;\n\nconst RobotImage = styled.img<{rotation: number}>`\n  transform: rotate(${({rotation}) => rotation}deg);\n  width: ${settings.TILE_SIZE_IN_PX}px;\n  height: ${settings.TILE_SIZE_IN_PX}px;\n`;","import { ICoordinate } from './interfaces';\nimport { generateGrid, getRandomAdjacentPosition, getRandomPosition } from './gridHelpers';\n\ntype State = { currentPosition: ICoordinate, grid: boolean[][] };\ntype Action = { type: 'RESET' | 'MOVE' };\n\n// returns a random start position and a new grid (with start position marked as cleaned)\nexport const getInitialState = () => {\n  const currentPosition = getRandomPosition();\n  const grid = generateGrid();\n  grid[currentPosition.y][currentPosition.x] = true;\n\n  return { grid, currentPosition };\n};\n\n// returns the next position and the grid (with new position marked as cleaned)\nconst getNextMove = (state: State) => {\n  const currentPosition = getRandomAdjacentPosition(state.currentPosition!);\n  const grid = state.grid.map((row, y) => {\n    return row.map((column, x) => {\n      const isCurrentPosition = (x === currentPosition.x && y === currentPosition.y);\n      return isCurrentPosition ? true : column;\n    });\n  });\n  return { grid, currentPosition };\n}\n\nexport const gridReducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case 'RESET':\n      return getInitialState();\n\n\n    case 'MOVE':\n      return getNextMove(state);\n\n    default:\n      throw new Error('Not a valid action: ' + action.type);\n  }\n};","import React, { useEffect, useState } from 'react'\nimport styled from 'styled-components';\nimport { settings } from './settings';\nimport { Floor, Robot } from './components';\nimport { getInitialState, gridReducer } from './gridReducer';\nimport { checkIsGridComplete } from './gridHelpers';\n\nconst App = () => {\n  const [state, dispatch] = React.useReducer(gridReducer, getInitialState());\n  const [totalTimeInMillis, setTotalTimeInMillis] = useState<number>(0);\n  const movementInterval = React.useRef<number>(0);\n\n  // TODO: Look up best practice for timeouts. This will probably break if anyhting updattes the component and interval is reset before running.\n  useEffect(() => {\n    if (!checkIsGridComplete(state.grid)) {\n      movementInterval.current = window.setInterval(() => {\n        setTotalTimeInMillis(totalTimeInMillis => totalTimeInMillis + settings.ROBOT_SPEED_IN_MILLIS);\n        dispatch({type: 'MOVE'});\n      }, settings.ROBOT_SPEED_IN_MILLIS);\n\n      return () => clearTimeout(movementInterval.current);\n    }\n  }, [state.grid]);\n\n  const handleReset = () => {\n    clearTimeout(movementInterval.current);\n    setTotalTimeInMillis(0);\n    dispatch({type: 'RESET'});\n  };\n\n  const secondsPassed = (totalTimeInMillis / 1000).toFixed(1);\n  const hasStarted = totalTimeInMillis > 0;\n\n  return (\n    <AppContainer>\n      <Room>\n        <Robot position={state.currentPosition} animate={hasStarted} />\n        <Floor grid={state.grid} />\n      </Room>\n      <Panel>\n        <Status complete={checkIsGridComplete(state.grid)}>\n          {checkIsGridComplete(state.grid)\n            ? `Cleaning complete in ${secondsPassed} seconds`\n            : 'Cleaning in progress'\n          }\n        </Status>\n        <ResetButton onClick={handleReset}>Reset</ResetButton>\n      </Panel>\n    </AppContainer>\n  );\n}\n\nconst AppContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  height: 100%;\n  flex-direction: column;\n  width: ${settings.GRID_SIZE * settings.TILE_SIZE_IN_PX}px;\n  margin: auto;\n`;\n\nconst Room = styled.div`\n  position: relative;\n  border-radius: 5px;\n  overflow: hidden;\n`;\n\nconst Panel = styled.div`\n  margin-top: 10px;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  font-size: 1.4rem;\n`;\n\nconst ResetButton = styled.button`\n  background-color: #eee;\n  color: #666;\n  border-radius: 5px;\n  border: none;\n  padding: 10px 20px;\n  font-size: 1.4rem;\n\n  &:hover {\n    background-color: #ccc;\n    cursor: pointer;\n  }\n`;\n\nconst Status = styled.p<{complete: boolean}>`\n  color: ${({complete}) => complete ? '#a4d2a4' : '#666'};\n  flex: 1;\n`;\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}